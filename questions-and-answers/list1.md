## Основы Golang (30 вопросов)

1. Что такое Golang и каковы его основные преимущества?
Ответ: Golang — это компилируемый, статически типизированный язык программирования, разработанный Google. Его преимущества включают простоту, высокую производительность, встроенную поддержку многозадачности (горутины) и сборку мусора.

2. Как объявить переменную в Golang?
Ответ: Можно использовать var, короткое объявление := или явное указание типа:
```go
    var x int = 10
    y := 20
```

3. Что такое горутина (goroutine)?
Ответ: Горутина — это легковесный поток, управляемый runtime Go. Запускается с помощью ключевого слова go.

4. Как работает defer в Golang?
Ответ: defer откладывает выполнение функции до завершения текущей функции. Вызовы defer выполняются в порядке LIFO (последний пришел — первый ушел).

5. Что такое каналы (channels) в Golang?
Ответ: Каналы — это механизм для обмена данными между горутинами. Они могут быть буферизированными и небуферизированными.

6. Как создать канал?
Ответ:
```go
    ch := make(chan int) // небуферизированный канал
    chBuffered := make(chan int, 10) // буферизированный канал
```
7. Что такое select в Golang?
Ответ: select позволяет ждать выполнения одной из нескольких операций с каналами.

8. Как работает interface{} в Golang?
Ответ: interface{} — это пустой интерфейс, который может содержать значение любого типа.

9. Что такое context и для чего он используется?
Ответ: context используется для передачи данных, отмены операций и установки тайм-аутов в горутинах.

10. Как работает сборщик мусора в Golang?
Ответ: Go использует concurrent mark-and-sweep сборщик мусора, который работает параллельно с программой.

11. Что такое make и new?
Ответ: make используется для создания slices, maps и channels, а new выделяет память для типа и возвращает указатель.

12. Как работает slice в Golang?
Ответ: Slice — это динамический массив, который ссылается на часть массива. Он имеет длину и емкость.

13. Как скопировать slice?
Ответ:

```go
    original := []int{1, 2, 3}
    copySlice := make([]int, len(original))
    copy(copySlice, original)
```

14. Что такое map в Golang?
Ответ: map — это коллекция пар ключ-значение.

15. Как проверить, существует ли ключ в map?
Ответ:

```go
    value, exists := myMap["key"]
    if exists {
    // ключ существует
}
```

16. Что такое struct в Golang?
Ответ: struct — это пользовательский тип данных, который группирует поля.

17. Как сравнить две структуры?
Ответ: Можно использовать пакет reflect или реализовать метод Equals.

18. Что такое теги (tags) в структурах?
Ответ: Теги — это метаданные, которые можно добавить к полям структуры. Например:

```go
    type User struct {
        Name string `json:"name"`
    }
```

19. Как работает json.Marshal?
Ответ: json.Marshal преобразует структуру в JSON.

20. Как работает json.Unmarshal?
Ответ: json.Unmarshal преобразует JSON в структуру.

21. Что такое panic и recover?
Ответ: panic вызывает аварийное завершение программы, а recover позволяет восстановить управление.
    
22. Как работает init функция?
Ответ: init выполняется автоматически при инициализации пакета.

23. Что такое go mod?
Ответ: go mod — это система управления зависимостями в Go.

24. Как добавить зависимость в проект?
Ответ:

```bash
  go get package-name
```

25. Как работает go vet?
Ответ: go vet анализирует код на наличие подозрительных конструкций.

26. Что такое go fmt?
Ответ: go fmt форматирует код в соответствии со стандартами Go.

27. Как работает go test?
Ответ: go test запускает тесты в проекте.

28. Что такое benchmark в Go?
Ответ: Benchmark — это тест производительности, который измеряет время выполнения кода.

29. Как написать benchmark в Go?
Ответ:

```go
    func BenchmarkFunction(b *testing.B) {
        for i := 0; i < b.N; i++ {
            // код для тестирования
        }
    }
```

30. Что такое race condition и как ее обнаружить?
Ответ: Race condition возникает, когда несколько горутин одновременно обращаются к общим данным. Для обнаружения используется go run -race.

### Продвинутые концепции (30 вопросов)

31. Что такое sync.WaitGroup?
Ответ: sync.WaitGroup используется для ожидания завершения группы горутин.

32. Как работает sync.Mutex?
Ответ: sync.Mutex обеспечивает эксклюзивный доступ к общим данным.

33. Что такое sync.RWMutex?
Ответ: sync.RWMutex позволяет нескольким читателям или одному писателю.

34. Как работает sync.Pool?
Ответ: sync.Pool используется для повторного использования объектов, чтобы уменьшить нагрузку на сборщик мусора.

35. Что такое atomic операции?
Ответ: atomic операции обеспечивают безопасное выполнение операций над переменными в многопоточной среде.

36. Как работает select с default?
Ответ: default выполняется, если ни один из каналов не готов.

37. Что такое buffered channel?
Ответ: Буферизированный канал позволяет отправлять данные без блокировки, пока буфер не заполнится.

38. Как закрыть канал?
Ответ: С помощью функции close.

39. Что произойдет, если отправить данные в закрытый канал?
Ответ: Это вызовет panic.

40. Как работает range с каналами?
Ответ: range читает данные из канала до его закрытия.

41. Что такое worker pool?
Ответ: Worker pool — это набор горутин, которые выполняют задачи из очереди.

42. Как реализовать worker pool в Go?
Ответ: С помощью каналов и горутин.

43. Что такое context.WithCancel?
Ответ: context.WithCancel создает контекст с функцией отмены.

44. Что такое context.WithTimeout?
Ответ: context.WithTimeout создает контекст с тайм-аутом.

45. Как работает context.WithValue?
Ответ: context.WithValue добавляет значения в контекст.

46. Что такое reflect в Go?
Ответ: reflect позволяет анализировать и изменять структуры данных во время выполнения.

47. Как работает unsafe пакет?
Ответ: unsafe позволяет обходить систему типов Go для низкоуровневых операций.

48. Что такое cgo?
Ответ: cgo позволяет вызывать C-код из Go.

49. Как работает go generate?
Ответ: go generate запускает команды, указанные в комментариях, для генерации кода.

50. Что такое go:embed?
Ответ: go:embed позволяет встраивать файлы в бинарник.

51. Как работает go:linkname?
Ответ: go:linkname позволяет ссылаться на неэкспортированные функции.

52. Что такое go:build?
Ответ: go:build определяет условия сборки.

53. Как работает go:generate?
Ответ: go:generate запускает команды для генерации кода.

54. Что такое go:noinline?
Ответ: go:noinline запрещает встраивание функции.

55. Как работает go:noescape?
Ответ: go:noescape указывает, что указатель не должен покидать стек.

56. Что такое go:notinheap?
Ответ: go:notinheap указывает, что объект не должен находиться в куче.

57. Как работает go:uintptrescapes?
Ответ: go:uintptrescapes указывает, что указатель может быть использован для побега.

58. Что такое go:systemstack?
Ответ: go:systemstack указывает, что функция должна выполняться в системном стеке.

59. Как работает go:nowritebarrierrec?
Ответ: go:nowritebarrierrec запрещает использование write barrier в функции.

60. Что такое go:yeswritebarrierrec?

61. Ответ: go:yeswritebarrierrec разрешает использование write barrier в функции.

### Архитектура и проектирование (20 вопросов)

62. Что такое чистая архитектура (Clean Architecture)?
Ответ: Это подход к проектированию, при котором система разделяется на слои, такие как доменный слой, слой приложения и инфраструктурный слой.

63. Как реализовать Dependency Injection в Go?
Ответ: С помощью передачи зависимостей через конструкторы или интерфейсы.

64. Что такое hexagonal architecture?
Ответ: Это архитектурный подход, при котором приложение разделяется на ядро и адаптеры.

65. Как реализовать CQRS в Go?
Ответ: С помощью разделения команд (запись) и запросов (чтение).

66. Что такое Event Sourcing?
Ответ: Это подход, при котором состояние системы восстанавливается из последовательности событий.

67. Как реализовать Event Sourcing в Go?
Ответ: С помощью хранения событий и применения их к состоянию.

68. Что такое DDD (Domain-Driven Design)?
Ответ: Это подход к проектированию, при котором основное внимание уделяется доменной логике.

69. Как реализовать DDD в Go?
Ответ: С помощью выделения доменных моделей и использования агрегатов.

70. Что такое микросервисы?
Ответ: Это архитектурный стиль, при котором приложение состоит из небольших независимых сервисов.

71. Как реализовать микросервисы в Go?
Ответ: С помощью gRPC, REST API и message brokers.

72. Что такое gRPC?
Ответ: gRPC — это фреймворк для удаленного вызова процедур, использующий Protocol Buffers.

73. Как работает Protocol Buffers?
Ответ: Protocol Buffers — это бинарный формат для сериализации данных.

74. Как реализовать REST API в Go?
Ответ: С помощью пакета net/http или фреймворков, таких как Gin или Echo.

75. Что такое middleware в Go?
Ответ: Middleware — это функции, которые обрабатывают запросы перед основным обработчиком.

76. Как реализовать middleware в Go?

Ответ:
```go
    func Middleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // логика middleware
            next.ServeHTTP(w, r)
        })
    }
```

77. Что такое rate limiting?
Ответ: Rate limiting — это ограничение количества запросов за определенный период времени.

78. Как реализовать rate limiting в Go?
Ответ: С помощью пакета golang.org/x/time/rate.

79. Что такое circuit breaker?
Ответ: Circuit breaker — это паттерн для предотвращения каскадных сбоев.

80. Как реализовать circuit breaker в Go?
Ответ: С помощью пакета github.com/sony/gobreaker.

81. Что такое service discovery?
Ответ: Service discovery — это механизм для автоматического обнаружения сервисов в распределенной системе.

### Тестирование (20 вопросов)

82. Как написать unit test в Go?
Ответ:
```go
    func TestFunction(t *testing.T) {
        result := Function()
        if result != expected {
            t.Errorf("Expected %v, got %v", expected, result)
        }
    }
```

83. Что такое table-driven tests?
Ответ: Это подход, при котором тестовые данные хранятся в таблице.

84. Как написать table-driven test?
Ответ:
```go
    func TestFunction(t *testing.T) {
        tests := []struct {
                input    int
                expected int
            }{
                {1, 2},
                {2, 4},
        }
        for _, test := range tests {
            result := Function(test.input)
        if result != test.expected {
            t.Errorf("Expected %v, got %v", test.expected, result)
        }
        }
    }
```

85. Что такое mock в тестировании?
Ответ: Mock — это объект, который имитирует поведение реального объекта.

86. Как создать mock в Go?
Ответ: С помощью пакетов, таких как gomock или testify/mock.

87. Что такое stub в тестировании?
Ответ: Stub — это объект, который возвращает заранее определенные данные.

88. Как создать stub в Go?
Ответ: С помощью реализации интерфейса с фиксированными данными.

89. Что такое integration test?
Ответ: Integration test проверяет взаимодействие между компонентами системы.

90. Как написать integration test в Go?
Ответ: С помощью тестирования реальных зависимостей, таких как базы данных или API.

91. Что такое end-to-end test?
Ответ: End-to-end test проверяет всю систему от начала до конца.

92. Как написать end-to-end test в Go?
Ответ: С помощью инструментов, таких как Selenium или Cypress.

93. Что такое benchmark test?
Ответ: Benchmark test измеряет производительность кода.

94. Как написать benchmark test в Go?
Ответ:
```go
    func BenchmarkFunction(b *testing.B) {
        for i := 0; i < b.N; i++ {
        Function()
        }
    }
```

95. Что такое race detector?
Ответ: Race detector — это инструмент для обнаружения гонок данных.

96. Как использовать race detector в Go?
Ответ: С помощью флага -race:
```bash
go run -race main.go
```

97. Что такое code coverage?
Ответ: Code coverage — это метрика, показывающая, какой процент кода покрыт тестами.

98. Как измерить code coverage в Go?
Ответ:
```bash
go test -cover
```

99. Что такое fuzz testing?
Ответ: Fuzz testing — это метод тестирования, при котором на вход подаются случайные данные.

100. Как написать fuzz test в Go?
Ответ:
```go
    func FuzzFunction(f *testing.F) {
        f.Fuzz(func(t *testing.T, input string) {
        Function(input)
        })
    }
```

101. Что такое property-based testing?
Ответ: Property-based testing — это метод тестирования, при котором проверяются свойства функции.

### Оптимизация и производительность (20 вопросов)

102. Как профилировать приложение в Go?
Ответ: С помощью пакета pprof.

103. Как использовать pprof для профилирования CPU?
Ответ:
```go
import _ "net/http/pprof"

go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```
Затем запустите:
```bash
go tool pprof http://localhost:6060/debug/pprof/profile
```
104. Как использовать pprof для профилирования памяти?
Ответ:
```bash
go tool pprof http://localhost:6060/debug/pprof/heap
```

105. Что такое escape analysis?
Ответ: Escape analysis — это анализ, который определяет, может ли переменная "убежать" из стека.

106. Как уменьшить количество аллокаций в Go?
Ответ: С помощью пулов объектов (sync.Pool) и избегания лишних копий.

107. Как оптимизировать производительность горутин?
Ответ: С помощью ограничения количества горутин и использования worker pool.

108. Как уменьшить использование памяти в Go?
Ответ: С помощью уменьшения размера структур и использования пулов.

109. Как оптимизировать работу с каналами?
Ответ: С помощью буферизированных каналов и избегания блокировок.

110. Как уменьшить нагрузку на сборщик мусора?
Ответ: С помощью уменьшения количества аллокаций и использования пулов.

111. Как оптимизировать работу с сетью в Go?
Ответ: С помощью использования пулов соединений и буферизации данных.

112. Как оптимизировать работу с базой данных в Go?
Ответ: С помощью использования пулов соединений и кэширования.

113. Как уменьшить задержки в Go?
Ответ: С помощью асинхронных операций и оптимизации алгоритмов.

114. Как оптимизировать работу с файлами в Go?
Ответ: С помощью буферизации и асинхронных операций.

115. Как уменьшить использование CPU в Go?
Ответ: С помощью оптимизации алгоритмов и использования пулов.

116. Как оптимизировать работу с JSON в Go?
Ответ: С помощью использования json-iterator или других оптимизированных библиотек.

117. Как уменьшить размер бинарника в Go?
Ответ: С помощью флагов -ldflags="-s -w" и удаления ненужных зависимостей.

118. Как оптимизировать работу с горутинами?
Ответ: С помощью ограничения количества горутин и использования worker pool.

119. Как уменьшить количество системных вызовов в Go?
Ответ: С помощью буферизации и асинхронных операций.

120. Как оптимизировать работу с памятью в Go?
Ответ: С помощью уменьшения количества аллокаций и использования пулов.

121. Как уменьшить количество блокировок в Go?
Ответ: С помощью использования sync.RWMutex и уменьшения времени удержания блокировок.

