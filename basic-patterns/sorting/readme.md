## Алгоритмы сортировки

### Сортировка пузырьком (Bubble Sort)
Принцип работы: Этот алгоритм работает путем многократного прохода по массиву и сравнения соседних элементов. Если два элемента расположены в неправильном порядке, они меняются местами. Процесс повторяется до тех пор, пока массив не окажется отсортированным.

Шаги:
- Сравниваем два соседних элемента.
- Если они находятся в неправильном порядке (например, первый больше второго), меняем их местами.
- Повторяем шаги 1 и 2 до конца массива.
- Повторяем весь процесс несколько раз, пока не произойдут больше ни одной перестановки.

Временная сложность: O(n^2) в худшем и среднем случаях. В лучшем случае (если массив уже отсортирован) — O(n).

Пространственная сложность: O(1), так как сортировка происходит на месте (без использования дополнительной памяти).

Преимущество: Простой в реализации.

Недостаток: Низкая производительность для больших массивов.

### Сортировка выбором (Selection Sort)
Принцип работы: В этом алгоритме на каждом шаге мы находим минимальный элемент в неотсортированной части массива и меняем его местами с первым элементом в этой части. Этот процесс повторяется, пока весь массив не будет отсортирован.

Шаги:
- Находим минимальный элемент в неотсортированной части массива.
- Меняем его местами с первым элементом неотсортированной части.
- Повторяем процесс для оставшейся части массива.

Временная сложность: O(n^2) во всех случаях.

Пространственная сложность: O(1).

Преимущество: Простота реализации.

Недостаток: Тоже неэффективен для больших массивов.

### Сортировка вставками (Insertion Sort)
Принцип работы: Вставка каждого элемента массива в отсортированную часть массива, сдвигая элементы, которые больше текущего.

Шаги:
- Берем текущий элемент и сравниваем его с элементами слева от него.
- Вставляем его в нужное место, сдвигая остальные элементы вправо.

Временная сложность: O(n^2) в худшем и среднем случаях. В лучшем случае (если массив уже отсортирован) — O(n).

Пространственная сложность: O(1).

Преимущество: Хорошо работает на небольших массивах и почти отсортированных данных.

Недостаток: Низкая производительность для больших массивов.

### Быстрая сортировка (Quick Sort)
Принцип работы: Выбирается опорный элемент (pivot), массив разделяется на две части: элементы, меньшие чем pivot, и элементы, большие чем pivot. Затем рекурсивно сортируются обе части.

Шаги:
- Выбираем опорный элемент (например, последний элемент массива).
- Разбиваем массив на две части: элементы меньше опорного и элементы больше опорного.
- Рекурсивно сортируем обе части.

Временная сложность: O(n log n) в среднем, O(n^2) в худшем случае (если выбор опорного элемента неудачен).

Пространственная сложность: O(log n) из-за рекурсии.

Преимущество: Очень быстрый для больших массивов.

Недостаток: В худшем случае может иметь плохую производительность.

### Сортировка слиянием (Merge Sort)
Принцип работы: Массив рекурсивно делится на две части, каждая из которых сортируется, а затем сливаются в один отсортированный массив.

Шаги:
- Разбиваем массив на две половины.
- Рекурсивно сортируем обе половины.
- Сливаем отсортированные половины в один отсортированный массив.

Временная сложность: O(n log n) во всех случаях.

Пространственная сложность: O(n), так как требуется дополнительная память для хранения объединенных массивов.

Преимущество: Отличная производительность при больших объемах данных.

Недостаток: Использует дополнительную память.


### Сортировка кучей (Heap Sort)
Принцип работы: Строится двоичная куча, затем из неё поочередно извлекаются элементы, и в итоге получается отсортированный массив.

Шаги:
- Строим кучу из массива.
- Извлекаем элементы из кучи поочередно и перестраиваем кучу после каждого извлечения.

Временная сложность: O(n log n) в худшем, среднем и лучшем случаях.

Пространственная сложность: O(1).

Преимущество: Очень быстрая сортировка, подходит для больших данных.

Недостаток: Не стабилен (порядок равных элементов может измениться).
